const fs = require('fs');
const path = require('path');
const { spawn, exec } = require('child_process');

// 🔧 Create "outputs" directory if it doesn't exist
const dirOp = path.join(__dirname, "outputs");
if (!fs.existsSync(dirOp)) {
    fs.mkdirSync(dirOp, { recursive: true });
}

/**
 * Executes a given code file in specified language, with optional stdin input
 * @param {string} filePath - Full path of the code file to execute
 * @param {string} language - Programming language: "C++" | "Python" | "Java"
 * @param {string} input - Input to be passed to the code via stdin
 * @returns {Promise<string>} - Output generated by the code
 **/
const executeFile = async (filePath, language, input = "") => {
    const JobId = path.basename(filePath).split(".")[0];

    let compileCmd, runCmd, runArgs = [];

    // 🧠 Prepare compile and run commands based on language
    switch (language) {
        case 'Python':
            compileCmd = null; // No compilation needed
            runCmd = 'python';
            runArgs = [filePath];
            break;

        case 'Java':
            compileCmd = `javac "${filePath}"`; // Compile: javac File.java
            runCmd = 'java';
            const className = path.basename(filePath).replace('.java', '');
            runArgs = ['-cp', path.dirname(filePath), className]; // Run: java -cp folder ClassName
            break;

        default: // C++ (or fallback)
            const outputPath = path.join(dirOp, `${JobId}.exe`);
            compileCmd = `g++ "${filePath}" -o "${outputPath}"`; // Compile: g++ file.cpp -o file.exe
            runCmd = outputPath;
            runArgs = [];
            break;
    }

    // 🔁 Main Promise to handle compile → run → result
    return new Promise((resolve, reject) => {

        // 🏃 Function to run the compiled/interpreted file
        const executeRun = () => {
            const runProcess = spawn(runCmd, runArgs);
            let output = "", error = "";

            // ✅ Send input to code (if any)
            if (input) {
                runProcess.stdin.write(input);
            }
            runProcess.stdin.end();

            // 🧾 Collect stdout
            runProcess.stdout.on("data", (data) => {
                output += data.toString();
            });

            // ⚠️ Collect stderr
            runProcess.stderr.on("data", (data) => {
                error += data.toString();
            });

            // 🔚 When process finishes
            runProcess.on("close", (code) => {
                if (code !== 0 || error) {
                    reject({ error: error || `Process exited with code ${code}` });
                } else {
                    resolve(output);
                }
            });
        };

        // ⚙️ If compilation is required (C++, Java)
        if (compileCmd) {

            exec(compileCmd, (compileError, stdout, stderr) => {
                if (compileError || stderr) {
                    return reject({ error: compileError?.message || stderr });
                }
                executeRun(); // Run only after successful compilation
            });
        } else {
            executeRun(); // For Python (no compilation)
        }
    });
};

module.exports = executeFile;
